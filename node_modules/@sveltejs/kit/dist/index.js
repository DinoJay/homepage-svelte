import { resolve as resolve$1 } from 'url';
import { join } from 'path';

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env);
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

let FORCE_COLOR$1, NODE_DISABLE_COLORS$1, NO_COLOR$1, TERM$1, isTTY$1=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR: FORCE_COLOR$1, NODE_DISABLE_COLORS: NODE_DISABLE_COLORS$1, NO_COLOR: NO_COLOR$1, TERM: TERM$1 } = process.env);
	isTTY$1 = process.stdout && process.stdout.isTTY;
}

const $$1 = {
	enabled: !NODE_DISABLE_COLORS$1 && NO_COLOR$1 == null && TERM$1 !== 'dumb' && (
		FORCE_COLOR$1 != null && FORCE_COLOR$1 !== '0' || isTTY$1
	)
};

function init$1(x, y) {
	let rgx = new RegExp(`\\x1b\\[${y}m`, 'g');
	let open = `\x1b[${x}m`, close = `\x1b[${y}m`;

	return function (txt) {
		if (!$$1.enabled || txt == null) return txt;
		return open + (!!~(''+txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
	};
}
const bold = init$1(1, 22);
const green = init$1(32, 39);
const yellow = init$1(33, 39);
const cyan = init$1(36, 39);

var options = {
	adapter: {
		default: [null],
		validate: (option, keypath) => {
			// support both `adapter: 'foo'` and `adapter: ['foo', opts]`
			if (!Array.isArray(option)) {
				option = [option];
			}

			// TODO allow inline functions
			assert_is_string(option[0], keypath);

			return option;
		}
	},

	amp: expect_boolean(false),

	appDir: expect_string('_app'),

	files: {
		default: {
			assets: expect_string('static'),
			routes: expect_string('src/routes'),
			setup: expect_string('src/setup'),
			template: expect_string('src/app.html')
		}
	},

	host: expect_string(null),

	hostHeader: expect_string(null),

	paths: {
		default: {
			base: expect_string(''),
			assets: expect_string('')
		}
	},

	prerender: {
		default: {
			crawl: expect_boolean(true),
			enabled: expect_boolean(true),
			force: expect_boolean(false),
			pages: {
				default: ['*'],
				validate: (option, keypath) => {
					if (!Array.isArray(option) || !option.every((page) => typeof page === 'string')) {
						throw new Error(`${keypath} must be an array of strings`);
					}

					option.forEach((page) => {
						if (page !== '*' && page[0] !== '/') {
							throw new Error(
								`Each member of ${keypath} must be either '*' or an absolute path beginning with '/' â€” saw '${page}'`
							);
						}
					});

					return option;
				}
			}
		}
	},

	// used for testing
	startGlobal: expect_string(null),

	target: expect_string(null)
};

function expect_string(string) {
	return {
		default: string,
		validate: (option, keypath) => {
			assert_is_string(option, keypath);
			return option;
		}
	};
}

function expect_boolean(boolean) {
	return {
		default: boolean,
		validate: (option, keypath) => {
			if (typeof option !== 'boolean') {
				throw new Error(`${keypath} should be true or false, if specified`);
			}
			return option;
		}
	};
}

function assert_is_string(option, keypath) {
	if (typeof option !== 'string') {
		throw new Error(`${keypath} should be a string, if specified`);
	}
}

function warn(msg) {
	console.log(bold(yellow(msg)));
}

function validate(definition, option, keypath) {
	for (const key in option) {
		if (!(key in definition)) {
			throw new Error(`Unexpected option ${keypath}.${key}`);
		}
	}

	const merged = {};

	for (const key in definition) {
		const expected = definition[key];
		const actual = option[key];

		const child_keypath = `${keypath}.${key}`;
		const has_children =
			expected.default && typeof expected.default === 'object' && !Array.isArray(expected.default);

		if (key in option) {
			if (has_children) {
				if (actual && (typeof actual !== 'object' || Array.isArray(actual))) {
					throw new Error(`${keypath}.${key} should be an object`);
				}

				merged[key] = validate(expected.default, actual, child_keypath);
			} else {
				merged[key] = expected.validate(actual, child_keypath);
			}
		} else {
			merged[key] = has_children ? validate(expected.default, {}, child_keypath) : expected.default;
		}
	}

	return merged;
}

function resolve(from, to) {
	// the `/.` is weird, but allows `${assets}/images/blah.jpg` to work
	// when `assets` is empty
	return remove_trailing_slash(resolve$1(add_trailing_slash(from), to)) || '/.';
}

function add_trailing_slash(str) {
	return str.endsWith('/') ? str : `${str}/`;
}

function remove_trailing_slash(str) {
	return str.endsWith('/') ? str.slice(0, -1) : str;
}

const expected = new Set(['compilerOptions', 'kit', 'preprocess']);

async function load_config({ cwd = process.cwd() } = {}) {
	const config_file = join(cwd, 'svelte.config.cjs');
	const config = await import(config_file);
	const validated = validate_config(config.default);

	// TODO check all the `files` exist when the config is loaded?
	// TODO check that `target` is present in the provided template

	return validated;
}

function validate_config(config) {
	for (const key in config) {
		if (!expected.has(key)) {
			warn(`Unexpected option ${key}${key in options ? ` (did you mean kit.${key}?)` : ''}`);
		}
	}

	const { kit = {} } = config;

	const validated = validate(options, kit, 'kit');

	if (validated.appDir === '') {
		throw new Error('kit.appDir cannot be empty');
	}

	// resolve paths
	if (validated.paths.base !== '' && !validated.paths.base.startsWith('/')) {
		throw new Error('kit.paths.base must be a root-relative path');
	}

	validated.paths.assets = resolve(validated.paths.base, validated.paths.assets);

	return validated;
}

export { $, bold as b, cyan as c, green as g, load_config as l };
//# sourceMappingURL=index.js.map
